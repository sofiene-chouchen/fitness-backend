import {
  debug_default
} from "./chunk-AQOK7X5X.js";

// src/formatters/values_formatter.ts
import formatters from "@poppinss/intl-formatter";
import { DateTime } from "luxon";

// src/formatters/relative_time_formatter.ts
var UNITS = {
  years: 24 * 60 * 60 * 1e3 * 365,
  months: 24 * 60 * 60 * 1e3 * 365 / 12,
  days: 24 * 60 * 60 * 1e3,
  hours: 60 * 60 * 1e3,
  minutes: 60 * 1e3,
  seconds: 1e3
};
var SECONDS_FORMATTER = {
  test: (diff) => diff < UNITS.minutes,
  format: (formatter, diff) => {
    return formatter.format(Math.floor(diff / UNITS.seconds), "seconds");
  }
};
var MINUTES_FORMATTER = {
  test: (diff) => diff < UNITS.hours,
  format: (formatter, diff) => {
    return formatter.format(Math.floor(diff / UNITS.minutes), "minutes");
  }
};
var HOURS_FORMATTER = {
  test: (diff) => diff < UNITS.days,
  format: (formatter, diff) => {
    return formatter.format(Math.floor(diff / UNITS.hours), "hours");
  }
};
var DAYS_FORMATTER = {
  test: (diff) => diff < UNITS.months,
  format: (formatter, diff) => {
    return formatter.format(Math.floor(diff / UNITS.days), "days");
  }
};
var MONTHS_FORMATTER = {
  test: (diff) => diff < UNITS.years,
  format: (formatter, diff) => {
    return formatter.format(Math.floor(diff / UNITS.months), "months");
  }
};
var YEARS_FORMATTER = {
  test: (_) => true,
  format: (formatter, diff) => {
    return formatter.format(Math.floor(diff / UNITS.years), "years");
  }
};
var UNITS_FORMATTER = [
  SECONDS_FORMATTER,
  MINUTES_FORMATTER,
  HOURS_FORMATTER,
  DAYS_FORMATTER,
  MONTHS_FORMATTER,
  YEARS_FORMATTER
];
function format(formatter, diff) {
  const absDiff = Math.abs(diff);
  return UNITS_FORMATTER.find(({ test }) => test(absDiff)).format(formatter, diff);
}

// src/formatters/values_formatter.ts
var DIFF_UNITS = {
  year: "years",
  years: "years",
  quarter: "quarters",
  quarters: "quarters",
  month: "months",
  months: "months",
  week: "weeks",
  weeks: "weeks",
  day: "days",
  days: "days",
  hour: "hours",
  hours: "hours",
  minute: "minutes",
  minutes: "minutes",
  second: "seconds",
  seconds: "seconds"
};
var Formatter = class {
  #locale;
  /**
   * The local for the formatter
   */
  get locale() {
    return this.#locale;
  }
  constructor(locale) {
    this.#locale = locale;
  }
  switchLocale(locale) {
    this.#locale = locale;
  }
  /**
   * Returns the diff between the current time and the user provided date
   *
   * - If the value is a string, we consider it as an ISODateTime string
   * - If value is a number, then we consider it as a diff in the user provided unit.
   */
  #getTimeDiff(value, unit) {
    const diffUnit = unit === "auto" ? "milliseconds" : DIFF_UNITS[unit];
    if (typeof value === "string") {
      return DateTime.fromISO(value).diff(DateTime.local(), diffUnit)[diffUnit];
    }
    if (DateTime.isDateTime(value)) {
      return value.diff(DateTime.local(), diffUnit)[diffUnit];
    }
    if (value instanceof Date) {
      return DateTime.fromJSDate(value).diff(DateTime.local(), diffUnit)[diffUnit];
    }
    return value;
  }
  /**
   * Format a numeric value for a given style
   */
  formatNumber(value, options) {
    value = typeof value === "string" ? Number(value) : value;
    return formatters.number(this.locale, options).format(value);
  }
  /**
   * Format a numeric value to a currency
   */
  formatCurrency(value, options) {
    const currencyOptions = { style: "currency", ...options };
    return this.formatNumber(value, currencyOptions);
  }
  /**
   * Format value as a date. The method accepts the following data
   * types.
   *
   * - Date instance
   * - Luxon DateTime instance
   * - Number representing a unix timestamp
   * - String representing an ISO date/time value
   */
  formatDate(value, options) {
    let normalizedDate;
    if (typeof value === "string") {
      normalizedDate = DateTime.fromISO(value).toJSDate();
    } else if (DateTime.isDateTime(value)) {
      normalizedDate = value.toJSDate();
    } else {
      normalizedDate = value;
    }
    return formatters.date(this.locale, options).format(normalizedDate);
  }
  /**
   * Format value as time. The method accepts the following data
   * types.
   *
   * - Date instance
   * - Luxon DateTime instance
   * - Number representing a unix timestamp
   * - String representing an ISO date/time value
   */
  formatTime(value, options) {
    if (!options) {
      options = { timeStyle: "medium" };
    } else if (!options.hour && !options.minute && !options.second) {
      options = { timeStyle: "medium", ...options };
    }
    return this.formatDate(value, options);
  }
  /**
   * Format value as relative diff between the current time
   * and the given value.
   *
   * The following data types are allowed
   *
   * - Date instance
   * - Luxon DateTime instance
   * - Number representing the diff value in provided units. If the "unit" is
   *   auto, the number will be considered as a diff in milliseconds
   * - String representing an ISO date/time value
   */
  formatRelativeTime(value, unit, options) {
    const diff = this.#getTimeDiff(value, unit);
    const formatter = formatters.relative(this.locale, { ...options || {} });
    return unit === "auto" ? format(formatter, diff) : formatter.format(typeof value === "number" ? diff : Math.floor(diff), unit);
  }
  /**
   * Format the value to its plural counter part
   */
  formatPlural(value, options) {
    return formatters.plural(this.locale, options).select(Number(value));
  }
  /**
   * Format an array of strings to a sentence.
   */
  formatList(list, options) {
    return formatters.list(this.locale, options).format(list);
  }
  /**
   * Format region, currency, language codes to their display names
   */
  formatDisplayNames(code, options) {
    return formatters.displayNames(this.locale, options).of(code);
  }
};

// src/vine_i18n_messages_provider.ts
import string from "@poppinss/utils/string";
var I18nMessagesProvider = class {
  /**
   * The validation messages prefix to use when reading translations.
   */
  #messagesPrefix;
  /**
   * The validation fields prefix to use when reading translations.
   */
  #fieldsPrefix;
  /**
   * Reference to i18n for formatting messages
   */
  #i18n;
  constructor(prefix, i18n) {
    this.#fieldsPrefix = `${prefix}.fields`;
    this.#messagesPrefix = `${prefix}.messages`;
    this.#i18n = i18n;
  }
  getMessage(defaultMessage, rule, field, meta) {
    let fieldName = field.name;
    const translatedFieldName = this.#i18n.resolveIdentifier(`${this.#fieldsPrefix}.${field.name}`);
    if (translatedFieldName) {
      fieldName = this.#i18n.formatRawMessage(translatedFieldName.message);
    }
    const fieldMessage = this.#i18n.resolveIdentifier(
      `${this.#messagesPrefix}.${field.wildCardPath}.${rule}`
    );
    if (fieldMessage) {
      return this.#i18n.formatRawMessage(fieldMessage.message, {
        field: fieldName,
        ...meta
      });
    }
    const ruleMessage = this.#i18n.resolveIdentifier(`${this.#messagesPrefix}.${rule}`);
    if (ruleMessage) {
      return this.#i18n.formatRawMessage(ruleMessage.message, {
        field: fieldName,
        ...meta
      });
    }
    return string.interpolate(defaultMessage, {
      field: fieldName,
      ...meta
    });
  }
};

// src/i18n.ts
var I18n = class extends Formatter {
  #i18nManager;
  #emitter;
  /**
   * Translations for the selected locale
   */
  localeTranslations;
  /**
   * Translations for the fallback locale. The fallback translations
   * are used when the selected locale translations are missing
   */
  fallbackTranslations;
  /**
   * The fallback locale for the current instance.
   */
  fallbackLocale;
  /**
   * Creates a messages provider for VineJS
   */
  createMessagesProvider(prefix = "validator.shared") {
    return new I18nMessagesProvider(prefix, this);
  }
  constructor(locale, emitter, i18nManager) {
    super(locale);
    this.#emitter = emitter;
    this.#i18nManager = i18nManager;
    this.fallbackLocale = this.#i18nManager.getFallbackLocaleFor(locale);
    this.localeTranslations = this.#i18nManager.getTranslationsFor(this.locale);
    this.fallbackTranslations = this.#i18nManager.getTranslationsFor(this.fallbackLocale);
    debug_default('creating i18n for locale "%s" with fallback locale "%s"', locale, this.fallbackLocale);
  }
  /**
   * Emits the missing translation message
   */
  #notifyForMissingTranslation(identifier, hasFallback) {
    this.#emitter.emit("i18n:missing:translation", {
      locale: this.locale,
      identifier,
      hasFallback
    });
  }
  /**
   * Returns the message for a given identifier
   */
  resolveIdentifier(identifier) {
    let message = this.localeTranslations[identifier];
    if (message) {
      return { message, isFallback: false };
    }
    message = this.fallbackTranslations[identifier];
    if (message) {
      return { message, isFallback: true };
    }
    return null;
  }
  /**
   * Returns a boolean identifying if the message for a given
   * identifier exists or not
   */
  hasMessage(identifier) {
    return this.localeTranslations[identifier] !== void 0;
  }
  /**
   * Returns a boolean identifying if a fallback message for a given
   * identifier exists or not
   */
  hasFallbackMessage(identifier) {
    return this.fallbackTranslations[identifier] !== void 0;
  }
  /**
   * Switch locale for the current instance
   */
  switchLocale(locale) {
    debug_default('switching locale from "%s" to "%s"', this.locale, locale);
    super.switchLocale(locale);
    this.fallbackLocale = this.#i18nManager.getFallbackLocaleFor(this.locale);
    this.localeTranslations = this.#i18nManager.getTranslationsFor(this.locale);
    this.fallbackTranslations = this.#i18nManager.getTranslationsFor(this.fallbackLocale);
  }
  /**
   * Formats a message using the messages formatter
   */
  formatMessage(identifier, data, fallbackMessage) {
    const message = this.resolveIdentifier(identifier);
    if (!message) {
      this.#notifyForMissingTranslation(identifier, false);
    } else if (message.isFallback) {
      this.#notifyForMissingTranslation(identifier, true);
    }
    if (message) {
      return this.formatRawMessage(message.message, data);
    }
    if (fallbackMessage !== void 0) {
      return fallbackMessage;
    }
    const globalFallbackMessage = this.#i18nManager.getFallbackMessage(identifier, this.locale);
    if (globalFallbackMessage !== void 0) {
      return globalFallbackMessage;
    }
    return `translation missing: ${this.locale}, ${identifier}`;
  }
  /**
   * Shorthand method for formatUsage
   * @alias formatUsage
   */
  t(identifier, data, fallbackMessage) {
    return this.formatMessage(identifier, data, fallbackMessage);
  }
  /**
   * Formats a message using the messages formatter
   */
  formatRawMessage(message, data) {
    return this.#i18nManager.getFormatter().format(message, this.locale, data);
  }
};

// src/i18n_manager.ts
import Negotiator from "negotiator";
var I18nManager = class {
  /**
   * i18n config
   */
  config;
  /**
   * Reference to the emitter for emitting events
   */
  #emitter;
  /**
   * Reference to the formatter in use
   */
  #formatter;
  /**
   * An array of supported locales inferred from the fallback locales
   * object + the translations directories.
   *
   * The array is only used when the config doesn't have an explicit
   * value.
   */
  #inferredLocales = [];
  /**
   * Cached in-memory translations. The collection is a merged
   * copy of a
   */
  #translations = {};
  /**
   * Find if translations has been cached or not
   */
  #hasCachedTranslations = false;
  /**
   * Reference to the default locale defined inside the config file
   */
  get defaultLocale() {
    return this.config.defaultLocale;
  }
  /**
   * Check if the translations has been cached or not.
   * Use "reloadTranslations" method re-fetch translations
   */
  get hasCachedTranslations() {
    return this.#hasCachedTranslations;
  }
  constructor(emitter, config) {
    this.config = config;
    this.#emitter = emitter;
  }
  /**
   * Returns an array of locales supported by the application.
   *
   * The method returns locales by inspecting the translations,
   * when no explicit supportLocales are defined inside the
   * config file.
   */
  supportedLocales() {
    return this.config.supportedLocales || this.#inferredLocales;
  }
  /**
   * Returns an object of cached translations. The object is shared
   * by reference and hence mutations will mutate the original
   * copy
   */
  getTranslations() {
    return this.#translations;
  }
  /**
   * Returns an object of translations for a given locale
   */
  getTranslationsFor(locale) {
    return this.#translations[locale] || {};
  }
  /**
   * Returns an instance of the translations formatter for the
   * active formatter
   */
  getFormatter() {
    if (!this.#formatter) {
      const formatterFactory = this.config.formatter;
      this.#formatter = formatterFactory(this.config);
    }
    return this.#formatter;
  }
  /**
   * Load translations using all the configured loaders.
   *
   * The loaded translations are cached forever and you must use
   * "reloadTranslations" method to reload them.
   */
  async loadTranslations() {
    if (!this.hasCachedTranslations) {
      await this.reloadTranslations();
    }
  }
  /**
   * Reload translations from the registered loaders
   */
  async reloadTranslations() {
    debug_default("loading translations");
    const translationsStack = await Promise.all(
      this.config.loaders.map((loaderFactory) => {
        return loaderFactory(this.config).load();
      })
    );
    this.#hasCachedTranslations = true;
    this.#translations = {};
    this.#inferredLocales = [this.defaultLocale].concat(
      this.config.fallbackLocales ? Object.keys(this.config.fallbackLocales) : []
    );
    translationsStack.forEach((translations) => {
      Object.keys(translations).forEach((lang) => {
        if (!this.#inferredLocales.includes(lang)) {
          this.#inferredLocales.push(lang);
        }
        this.#translations[lang] = this.#translations[lang] || {};
        Object.assign(this.#translations[lang], translations[lang]);
      });
    });
  }
  /**
   * Returns the most appropriate supported locale based upon the user
   * languages
   */
  getSupportedLocaleFor(userLanguage) {
    return new Negotiator({
      headers: {
        "accept-language": Array.isArray(userLanguage) ? userLanguage.join(",") : userLanguage
      }
    }).language(this.supportedLocales()) || null;
  }
  /**
   * Returns the fallback locale for a given locale. Returns the default
   * locale when no fallback is defined
   */
  getFallbackLocaleFor(locale) {
    if (this.config.fallbackLocales && this.config.fallbackLocales[locale]) {
      return this.config.fallbackLocales[locale];
    }
    const closestMatchingLanguages = new Negotiator({
      headers: {
        "accept-language": locale
      }
    }).languages(this.supportedLocales());
    for (let matchingLocale of closestMatchingLanguages) {
      if (matchingLocale !== locale) {
        return matchingLocale;
      }
    }
    return this.defaultLocale;
  }
  /**
   * Returns an instance of I18n for a given locale
   */
  locale(locale) {
    return new I18n(locale, this.#emitter, this);
  }
  /**
   * Returns the fallback message for an identifier and locale
   * when the "config.fallback" property is defined.
   *
   * Otherwise returns undefined
   */
  getFallbackMessage(identifier, locale) {
    return this.config.fallback?.(identifier, locale);
  }
};

export {
  I18n,
  I18nManager
};
//# sourceMappingURL=chunk-ALNS7L4X.js.map