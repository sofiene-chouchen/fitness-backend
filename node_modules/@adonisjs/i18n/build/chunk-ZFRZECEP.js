import {
  debug_default
} from "./chunk-AQOK7X5X.js";

// src/loaders/fs.ts
import yaml from "yaml";
import { fileURLToPath } from "node:url";
import { join, extname } from "node:path";
import { readFile } from "node:fs/promises";
import { flatten, fsReadAll } from "@poppinss/utils";
var FsLoader = class {
  /**
   * Base path for translation files
   */
  #storageBasePath;
  constructor(config) {
    this.#storageBasePath = config.location instanceof URL ? fileURLToPath(config.location) : config.location;
  }
  /**
   * File types supported by the FsLoader
   */
  #supportedFileTypes = [".json", ".yaml", ".yml"];
  /**
   * Processes the messages for a given file and writes them to the
   * messages bag.
   *
   * @note: The messagesBag property is mutated internally
   */
  #processFileTranslations(filePath, messages, messagesBag) {
    const [lang, ...nestedPath] = filePath.replace(new RegExp(`${extname(filePath)}$`), "").split(/\/|\\/g);
    messagesBag[lang] = messagesBag[lang] || {};
    if (!nestedPath.length) {
      messagesBag[lang] = messages;
      return;
    }
    messagesBag[lang][nestedPath.join(".")] = messages;
  }
  /**
   * Wraps JSON.parse to raise exception with the file path when
   * unable to parse JSON
   */
  #parseJSON(filePath, contents) {
    try {
      return JSON.parse(contents);
    } catch (error) {
      const stack = error.stack.split("\n");
      stack.splice(1, 0, `    at anonymous (${filePath})`);
      error.stack = stack.join("\n");
      throw error;
    }
  }
  /**
   * Processes the message inside a JSON file
   */
  async #processJSONFile(filePath, messagesBag) {
    debug_default('loading translations from "%s"', filePath);
    const contents = await readFile(join(this.#storageBasePath, filePath), "utf-8");
    const messages = this.#parseJSON(filePath, contents);
    this.#processFileTranslations(filePath, messages, messagesBag);
  }
  /**
   * Wraps JSON.parse to raise exception with the file path when
   * unable to parse JSON
   */
  #parseYaml(filePath, contents) {
    try {
      return yaml.parse(contents);
    } catch (error) {
      const offset = error.source?.range?.start;
      const stack = error.stack.split("\n");
      if (offset) {
        stack[0] = `${stack[0]} (at offset ${offset})`;
      }
      stack.splice(1, 0, `    at anonymous (${filePath})`);
      error.stack = stack.join("\n");
      throw error;
    }
  }
  /**
   * Processes the message inside a YAML file
   */
  async #processYamlFile(filePath, messagesBag) {
    debug_default('loading translations from "%s"', filePath);
    const contents = await readFile(join(this.#storageBasePath, filePath), "utf-8");
    const messages = this.#parseYaml(filePath, contents);
    this.#processFileTranslations(filePath, messages, messagesBag);
  }
  /**
   * Returns an array of file paths for translation files.
   */
  #getTranslationFiles() {
    return fsReadAll(this.#storageBasePath, {
      filter: (file) => !!this.#supportedFileTypes.find((ext) => file.endsWith(ext)),
      ignoreMissingRoot: true
    });
  }
  /**
   * Loads messages from the lang directory
   */
  async load() {
    const messagesBag = {};
    const translationFiles = await this.#getTranslationFiles();
    await Promise.all(
      translationFiles.map((file) => {
        if (file.endsWith(".json")) {
          return this.#processJSONFile(file, messagesBag);
        } else {
          return this.#processYamlFile(file, messagesBag);
        }
      })
    );
    return Object.keys(messagesBag).reduce((result, lang) => {
      result[lang] = flatten(messagesBag[lang]);
      return result;
    }, {});
  }
};

export {
  FsLoader
};
//# sourceMappingURL=chunk-ZFRZECEP.js.map